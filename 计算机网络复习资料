整理一下之前找工作时复习的一些计算机网络知识。
由于时间关系，比较少，主要是针对面试的。现在记录的也比较简单，后面有时间会不断完善。

四层模型：应用层，传输层，网络层，数据链路层
七层模型：应用层，会话层，表示层，网络层，传输层，数据链路层，物理层

应用层的协议：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 
传输层的协议：TCP，UDP
网络层的协议：IP，ICMP，OSPF，EIGRP，IGMP
数据链路层的协议：SLIP，CSLIP，PPP，MTU

TCP三次握手的过程：
第一步：客户端发送报文（SYN=1，seq=client_isn）给服务器端
第二步：服务器端回应一个报文（SYN=1，seq=server_isn，ack=client_isn+1）
第三步：客户端回应一个报文（SYN=0，seq=client_isn+1，ack=server_isn+1）

TCP四次挥手的过程：
第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

HTTP协议
客户端发送一个HTTP请求到服务器的请求消息包括以下格式：
请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。
第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
第三部分：空行，请求头部后面的空行是必须的
第四部分：请求数据也叫主体，可以添加任意的其他数据。

HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
第二部分：消息报头，用来说明客户端要使用的一些附加信息
第三部分：空行，消息报头后面的空行是必须的
第四部分：响应正文，服务器返回给客户端的文本信息。

TCP与UDP区别总结：
1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 ? 证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
? UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

流量控制
通过控制接受窗口的大小来控制发送方的发生速率

拥塞控制
加性增、乘性减（快速恢复）；慢启动；对超时事件作出反应

为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
解释原因：
TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的(
即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.
关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须
通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.
另一种解释：
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，
它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。
但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；
但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,
也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了
，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

为什么不能两次握手能进行连接？
我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，
也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，
假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，
S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，
将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。
在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。
而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。
